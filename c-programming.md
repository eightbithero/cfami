Программирование игр для NES на C
==========================
  
**Введение**

Эта статья предназначена для тех, кто хотел бы начать разработку программного обеспечения для NES, но пока не готов к программированию больших проектов на ассемблере 6502, и ищет более простую, высокоуровневую альтернативу. В ней рассматриваются многие темы, связанные с программированием игр для NES на языке C с использованием [компилятора CC65](http://www.cc65.org/), а в качестве примера приводится [специально разработанная простая игра](https://shiru.untergrund.net/files/nes/chase.zip).  
  
Цель разработки примера игры заключалась в том, чтобы предоставить реальный, законченный проект с очень простым и коротким кодом, в котором легко разобраться. Мои предыдущие проекты были довольно большими и почти полностью лишены комментариев, поэтому они не слишком хороши для использования в качестве примера. Пример игры также включает в себя последнюю версию моего низкоуровневого кода, который был разработан и использован в моих предыдущих проектах NES.  
  
Если код примера игры все еще слишком велик и сложен для понимания, посмотрите [эти небольшие примеры программ](https://shiru.untergrund.net/files/src/cc65_nes_examples.zip), которые также используют тот же низкоуровневый код и демонстрируют, как делать некоторые простые вещи, такие как вывод текста или спрайтов.  
  
  
  
**Что вам нужно знать**  
  
Чтобы создать игру для NES, нужно обладать множеством предварительных знаний. Невозможно дать даже краткое объяснение всего, что связано с этим, в одной статье, так что ознакомьтесь с этим списком, если вы чего-то не знаете, вам, вероятно, придется это где-то узнать. В мире существует множество книг и статей об этих вещах. Практически всю информацию по NES вы можете найти в вики и на форумах [NesDev](http://nesdev.com/).  
  

* Хорошее знание языка C.

> * Побитовые операции и сдвиг битов
> * Вычисления с фиксированной точкой
> * Указатели

* Базовые знания о процессоре 6502

> * Регистры
> * Нулевая страница
> * Страница стека

* Базовые знания аппаратного обеспечения NES, особенно PPU

> * CHR ROM
> * Nametables
> * Палитры
> * Спрайты
> * Таймер VBlank и доступ к VRAM
> * Карты памяти CPU и PPU

* Командная строка Windows и пакетные файлы

  
  
**Плюсы и минусы**  
  
Программирование для NES на C имеет два основных недостатка по сравнению с программированием на ассемблере. Во-первых, скомпилированный код всегда медленнее, чем написанный вручную на ассемблере. Во-вторых, он всегда намного больше. Размер на самом деле может быть даже более важен, чем скорость. С другой стороны, код меньшего размера обычно тоже быстрее.  
  
Взамен этих недостатков есть преимущество - вы можете разрабатывать программы на C гораздо быстрее, потому что вам нужно писать, отлаживать и обслуживать в несколько раз меньше кода, а сам код гораздо более читабелен. Кроме того, вы получаете некоторую абстракцию от аппаратного обеспечения, так что вы, вероятно, сможете сделать простую программу для NES даже без знания ассемблера 6502, хотя это, конечно, может помочь.  
  
Вот практический пример, который может убедить вас в том, что C действительно экономит время: написанный вручную ассемблерный код для получения значения из массива карт 32x32, используя две 8-битные координаты (mx,my), и его эквивалент на C:  
  

> ; версия на ассемблере  
>   
> lda my ;умножить my на 32  
> sta ptr\_h ;через сдвиг  
> ldy #0 ;16-битная переменная (ptr\_h,ptr\_l)  
> sty ptr\_l ;вправо три раза  
> dup 3  
> lsr ptr\_h ;сдвиг  
> ror ptr\_l  
> edup  
> lda ptr\_l ;добавить mx как 16-битное значение  
> clc  
> adc mx  
> bcc @1  
> inc ptr\_h  
> @1:  
> clc  
> adc #<map ;добавить смещение карты  
> sta ptr\_l  
> lda ptr\_h  
> adc #>map  
> sta ptr\_h  
> lda \[ptr\_l\],y ;считываем значение  

> // Версия на C  
>   
> n=map\[(my<<5)+mx\];  

  
  
  
**Оптимизация**  
  
Из-за очень ограниченных ресурсов NES, таких как скорость процессора, объем ОЗУ и ПЗУ, написание правильного, чистого кода на C не очень эффективно. Чтобы сделать его быстрее и короче, необходимо оптимизировать его, делая вещи, которые иначе не считаются приемлемыми. Они лишают C некоторых преимуществ, делая код более низкоуровневым и менее структурированным, но даже с этими ограничениями он остается очень высокоуровневым по сравнению с ассемблером.  
  
Есть предложения, которые сделают ваш код более эффективным, но, конечно, менее читабельным:  
  
* По возможности избегайте локальных переменных, сделайте их хотя бы статическими.
* Избегайте передачи параметров в функции
* Избегайте использования функций, которые используются только один раз.
* Используйте соглашение о вызове \_\_\_fastcall\_\_\_.
* Массивы структур медленные, отдельные массивы быстрее
* Самый быстрый тип - unsigned char, используйте его как можно чаще. Не забывайте, что в CC65 int имеет ширину 16 бит.
* Знаковые типы медленнее
* Вы можете поместить некоторые переменные в нулевую страницу с помощью прагмы (см. ниже), это сделает их быстрее
* Не забывайте, что массив указателей нужно объявлять как const type\* const, если вам нужно поместить его в ПЗУ.
* По возможности используйте преинкременты, они и быстрее, и короче.
* По возможности избегайте использования умножения и деления, они очень медленные. Вместо этого используйте битовые сдвиги, где это возможно
* Если вам нужно обработать массив объектов, лучше копировать данные из массивов в отдельные vars. Используйте эти переменные в коде, а затем копируйте новые данные обратно в массивы. Это может сделать код значительно короче и быстрее, поскольку обращение к элементу массива генерирует больше кода, чем обращение к переменной
* Объявление глобальных переменных как статических также помогает найти неиспользуемые глобальные переменные, компилятор сообщит о них.
  
  
Если ваша программа упирается в лимит процессора, и вам нужно максимально оптимизировать C-код, вы можете профилировать его с помощью некоторых отладочных эмуляторов NES. Например, существует версия VirtuaNES, которая может измерять время в процессорных часах между двумя записями в специальные виртуальные регистры $401e и $401f. Эмулятор отображает время на экране. За один кадр проходит около 30000 процессорных часов, так что вы можете иметь представление о том, сколько времени занимает та или иная часть кода, и посмотреть, как ваши изменения в коде влияют на время выполнения.  
  
**Настройка и первая компиляция**  
  
Прежде чем объяснять, как некоторые вещи были сделаны в примере игры, неплохо было бы настроить инструменты и скомпилировать игру самостоятельно.  
  
Моя среда разработки NES очень примитивна, я не использую IDE или что-то еще. Только Notepad++ в качестве редактора кода, CC65 в качестве компилятора командной строки, несколько bat-файлов для автоматизации сборки и эмулятор для тестирования. Я также использую набор инструментов для создания ресурсов, подробнее об этом позже.  
  
Скачайте CC65 и распакуйте его в каталог, например c:\\\cc65 - в этот каталог будут помещены такие папки, как \\bin\\\, \\\include\\\, \\\lib\\\ и т.д. Распакуйте исходный код примера игры в каталог cc65, так что он будет находиться в отдельной папке. Скрипт сборки использует относительный путь, поэтому больше ничего делать не нужно - просто запустите compile.bat. После компиляции он приостановится, чтобы вы могли посмотреть, нет ли ошибок, а после нажатия клавиши запустит скомпилированную игру в эмуляторе, если у вас есть такой, который связан с файлами \*.nes.  
  
Вы можете изменить процесс сборки, отредактировав compile.bat, или настроить IDE. Вы можете использовать функцию "запустить" в редакторе кода, например, кнопку F5 в Notepad++, но вам, вероятно, придется отредактировать скрипт сборки, добавив абсолютные пути. Я не могу дать подробное объяснение всех этих возможностей, поэтому исследуйте и делайте это самостоятельно.  
  
  
  
**Низкоуровневый код и конфигурация**  
  
В примере игры есть несколько частей кода низкого уровня. В большинстве случаев вы не будете с ними работать напрямую, но в некоторых случаях это может понадобиться, поэтому будет полезно вкратце ознакомиться с этими файлами, чтобы понять, зачем они нужны. Эти части находятся в файлах \*.s, \*.lib и \*.cfg.  
  
_crt0.s_ - код запуска. Он инициализирует оборудование, библиотеки и т.д. В начале файла есть несколько настроек, которые, возможно, придется изменить, если вам нужно использовать различные виды зеркалирования в вашем проекте или, например, использовать маппер.  
  
_runtime.lib_ - среда выполнения C, т.е. некоторый важный код базовой функциональности языка, например, математические подпрограммы. Это пользовательская компиляция, которая не содержит никакого специфического для NES кода. Если вам по какой-то причине понадобится изменить его, вам придется получить исходный код CC65 и немного поразвлечься, компилируя его с помощью GNU make.  
  
_nes.cfg_ - определение расположения памяти NES. Он настроен для проекта NROM128, если вам нужно сделать NROM256, добавить сэмплы или добавить дополнительную поддержку RAM, вам нужно будет отредактировать и его.  
  
  
Чтобы добавить некоторую абстракцию от аппаратного обеспечения и сделать аппаратно-зависимые операции более быстрыми, есть также моя собственная низкоуровневая часть, которая реализует некоторые функции языка C. Вы можете свободно использовать ее в своих проектах или использовать в качестве примера для создания собственного кода, если этот не содержит всего, что вам нужно. Можно назвать его библиотекой, но на самом деле он предоставляется в виде исходного кода сборки, поскольку проекты NES обычно требуют небольших доработок, например, удаления ненужной функциональности для экономии места.  
  
_neslib.s_ - сама пользовательская библиотека  
_neslib.h_ - прототипы C для функций библиотеки. Имеются комментарии, документирующие функции.  
  
Пользовательская библиотека также включает в себя код звуковой библиотеки FamiTone2 и звуковые данные в нескольких отдельных файлах:  
  
_famitone.s_ - звуковая библиотека, воспроизводящая музыку и звуковые эффекты  
_sounds.s_ - данные звуковых эффектов, сгенерированные инструментом nsf2data  
_music.s_ - музыкальные данные, сгенерированные инструментом text2data  
  
  
  
**Игровой код и ресурсы**  
  
Сам код игры содержится в файлах \*.c и \*.h. В случае примера игры это просто файл game.c.  
  
Ресурсов также очень много. Они представлены по-разному - \*.h файлы (таблицы имен), \*.s файлы (музыка), \*.chr файлы (графика). Потенциально файлы \*.h и \*.s могут использоваться для чего угодно, а также включать в себя различные бинарные форматы. Обычно эти файлы генерируются автоматически с помощью инструментов, так что не удивляйтесь, почему внутри так много цифр без каких-либо пояснений.  
  
О самом коде игры говорить особо нечего - учитывайте всю информацию из этой статьи и читайте комментарии в коде, их там предостаточно.  
  
Важнее объяснить, как сделать все игровые ресурсы, потому что просто уметь писать и компилировать код недостаточно для создания игры. Еще одна важная вещь - как обращаться с некоторыми вещами, связанными с программированием в целом.  
  
  
  
**Графика  
  
В игре NROM есть два набора графических элементов 8x8, которые также называются символами, шаблонами или тайлами. В каждом наборе их 256. Вы можете использовать один из наборов для фоновой графики, а другой - для спрайтов. В качестве альтернативы можно поместить фоновую и спрайтовую графику в один набор, слегка измененную копию - в другой, и переключаться между наборами для создания грубой двухкадровой анимации. Именно так сделана анимация в примере игры.  
  
Вся графика для примера игры создана с помощью [NES Screen Tool](http://shiru.untergrund.net/files/nesst.zip) с нуля, т.е. нарисована с помощью встроенного редактора CHR. Инструмент выводит графику в виде файла \*.chr, в примере игры это tileset.chr. Там же можно редактировать палитры и таблицы имен, их можно сохранять в разных форматах или копировать/вставлять как куски данных прямо в исходный код.  
  
Большие буквы и цифры также рисовались с помощью NES Screen Tool. Сейчас они выглядят беспорядочно в тайлсете, но я не рисовал их таким образом. Вместо этого я использовал области 2x3 плитки для каждого символа, чтобы они имели свою истинную форму в наборе плиток. Однако это привело к появлению большого количества повторяющихся или пустых плиток. Для экономии места была использована функция Optimize инструмента. Чтобы упростить работу, я сначала создал таблицы для экранов Level, Game Over и Well Done с неоптимизированным набором тайлов, а также дополнительную таблицу с большими числами. Затем я загрузил все таблицы с неоптимизированным набором тайлов и использовал Optimize - это перестроило загруженные таблицы под оптимизированную версию набора тайлов. Такой подход избавил меня от необходимости решать головоломку по созданию экранов из перепутанных кусков оптимизированного тайлсета.  
  
Если вам нужно работать с более сложной, крупной графикой, чем в примере игры, NES Screen Tool может оказаться не очень удобным. В этом случае вы можете использовать обычный графический редактор общего назначения для создания графики в соответствии с ограничениями NES, а затем конвертировать и подправить ее с помощью NES Screen Tool. Подробности смотрите в документации, прилагаемой к инструменту.  
  
Я в основном использую [GraphicsGale](http://www.humanbalance.net/gale/us/) как универсальный редактор пиксель-арта, иногда [GIMP](http://www.gimp.org/). Вы можете использовать эти или любые другие, просто убедитесь, что ваш графический редактор обладает некоторыми функциями, которые значительно облегчают подобную работу. К таким функциям относятся:  
  
* сетки 8x8 и 16x16, чтобы легче отслеживать, сколько цветов вы использовали в ячейке, и правильно выравнивать графику.
* Функция привязки к сетке, полезная, когда нужно переместить графику без потери выравнивания.
* Слои всегда полезны
* Управление индексированной палитрой, возможность перемещать цвета по палитре, очень полезно для подготовки графики к конвертации
  
  
**Большие спрайты**.  
  
Графическое оборудование NES способно отображать только маленькие спрайты, размером 8x8 или 8x16. Моя низкоуровневая библиотека поддерживает только режим 8x8. Чтобы получить более крупные спрайты, нужно сконструировать их из нескольких мелких. Это называется метаспрайтом. Чтобы работать с метаспрайтами в моей библиотеке, вы должны определить их как массив номеров тайлов, атрибутов и смещений от точки поворота.  
  
Если ваши метаспрайты представляют собой прямоугольник, состоящий из нескольких тайлов, расположенных на обычной сетке 8x8, вы можете использовать NES Screen Tool для генерации определений. Вы рисуете метаспрайт так же, как и часть nametable, затем выделяете часть nametable со спрайтом и используете функцию Nametable/Copy metasprite программы. Она поместит определение в буфер обмена, и вы сможете вставить его в свой исходный код. Можно также автоматически сгенерировать горизонтально перевернутую копию - таким образом, вы будете использовать только один набор графики для левой и правой версий, но два определения метаспрайта. В своей библиотеке я посчитал, что переворачивание определения метаспрайта во время выполнения программы неприемлемо, потому что это медленно, а такие определения не занимают много памяти.  
  
Для сложных метаспрайтов, которые не выровнены по обычной сетке, вам придется писать определения вручную.  
  
  
  
**Уровни**  
  
Во всех моих проектах для NES, написанных на C, включая пример игры, я использовал NES Screen Tool в качестве редактора уровней. Он хорошо подходит для простых игр, вы просто рисуете и сохраняете уровень в виде таблицы. Для более сложных игр вам придется создать собственный редактор или сделать скрипт экспорта для редактора общего назначения, такого как Tiled.  
  
Обратите внимание, что в примере массив карт игры в памяти в два раза меньше, чем таблица уровней. Уровни хранятся в виде упакованных в RLE именных таблиц, распаковываются непосредственно в VRAM, а затем считываются обратно строка за строкой для построения массива карт. Позиции спавна объектов также определены в таблицах имен, они удаляются в процессе, а строки записываются обратно в VRAM. Это не очень просто, но работает достаточно хорошо, и в конечном итоге все упрощается - не нужен специальный редактор карт, который выводит карту в оптимальном формате, не нужно строить таблицы имен из этого оптимального формата во время выполнения.  
  
  
  
**Звуковые эффекты**  
  
Звуковые эффекты созданы в [FamiTracker](http://famitracker.com/) для требований [FamiTone2](http://shiru.untergrund.net/files/src/famitone2.zip). Требования к звуку и музыке подробно описаны в документации FamiTone2. Вкратце процесс создания звуковых эффектов выглядит так: вы создаете их в FamiTracker в виде многопесенного файла, каждый эффект - это песня, которая заканчивается командой C00. Затем вы экспортируете NSF-файл и конвертируете его в файл сборки:




nsf2data sounds.nsf -ca65




Полученный файл sounds.s помещается в каталог проекта, он всегда включается в проект из crt0.s. Если вам не нужны звуковые эффекты в вашем проекте, вы можете отключить их с помощью define. При этом будет исключен и весь связанный с ними код.  
  
В примере игры очень мало звуковых эффектов, поэтому работа с приоритетами не очень хорошо показана. Для звуковых эффектов существует четыре виртуальных канала, пронумерованных от 0 до 3. Виртуальные каналы смешиваются с музыкой и друг с другом по громкости (более громкие части имеют приоритет), за исключением треугольного канала, который всегда перекрывается каналом звукового эффекта с более высоким номером. Если на канале запускается новый эффект, в то время как там играет другой эффект, старый эффект будет остановлен. Поэтому важно спланировать, какие эффекты должны перебивать друг друга, а какие нет, и поместить их на разные виртуальные каналы.  
  
  
  
**Музыка**  
  
Музыка также создается в FamiTracker для требований FamiTone2. Все песни создаются как многопесенный файл, поэтому они используют один и тот же набор инструментов. Затем они экспортируются с помощью встроенного в FamiTracker текстового экспортера и преобразуются в файл сборки:


> text2data music.txt -ca65  


Если набор функций FamiTone2 для вас слишком ограничен, вы можете подключить родной плеер FamiTracker. Его код компилируется с помощью ca65, но это потребует некоторой работы, требующей знания ассемблера 6502, особенно если вам нужна поддержка звуковых эффектов. Кроме того, он в три раза больше и в два раза медленнее, так что принимайте решение, исходя из того, сколько свободной памяти и процессорного времени у вас есть в проекте.  
  
  
  
**PAL и NTSC**.  
  
Один важный момент, характерный для всех компьютерных систем, использующих телевизор в качестве устройства отображения, включая NES, - это разница между NTSC и PAL. Поскольку частота кадров телевизора является основным источником синхронизации в программах для этих систем, а она различается на 17 % (50 или 60 Гц вертикального обновления), ее необходимо как-то обрабатывать. В общем случае это можно сделать тремя способами.  
  
Первый и, вероятно, самый верный - заставить программу использовать вычисления с фиксированной точкой везде, и создать две версии программы - одну с постоянными значениями (такими как скорость объекта), рассчитанными для NTSC, а другую - со значениями, рассчитанными для PAL. Константы PAL - это NTSC\*18/15.  
  
Хранить две версии одной и той же программы может быть довольно неудобно, поэтому второй способ заключается в том, чтобы заставить программу определять, какая система используется, и использовать один из двух наборов констант. Этот способ позволяет иметь только одну версию программы, но он все равно неудобен. Мало того, что вам приходится делать все вычисления в фиксированной точке, так еще и константы теперь не совсем константы, поскольку они меняются в зависимости от системы - так что вам нужно либо использовать переменные, либо иметь две версии некоторых частей кода.  
  
В моей библиотеке используется третий способ, который не очень точен, но зато свободен от недостатков первых двух методов. Он определяет систему при запуске и пропускает каждый шестой кадр, если программа работает на консоли NTSC. Таким образом, вам достаточно один раз подстроить тайминги для PAL, и они будут работать так же и на NTSC, с небольшим добавлением рывков в движениях. Это используется во всех моих играх для NES, так что вы можете проверить их, чтобы решить, заметно это или нет. Если вы хотите использовать мою библиотеку, но хотите решить проблему PAL/NTSC другим способом, вы можете отключить framekip через define в crt0.s.  
  
В любом случае моя библиотека компенсирует разницу в скорости воспроизведения музыки, но не в высоте тона и скорости звуковых эффектов. Это компромисс между загрузкой процессора и дополнительным размером ПЗУ, который я посчитал приемлемым. Вы можете изменить эти вещи, если захотите, но это потребует некоторых изменений в низкоуровневой части, таких как добавление второй таблицы частоты нот и, возможно, второй копии данных звуковых эффектов.  
  
Еще один момент, который вы должны помнить: время VBlank в PAL намного больше, и это единственное время, когда доступ к VRAM возможен при включенном дисплее. Это время используется системой обновления библиотеки, которая управляется командой vram\_set\_update, и может быть использовано для таких вещей, как отображение статистики игры или прокрутка уровней. Если вы хотите, чтобы ваша программа корректно работала на обеих системах, отлаживайте ее в NTSC - если она там работает, то гарантированно будет работать и в PAL, но не наоборот.  
  
  
  
**Использование оперативной памяти**  
  
При разработке программ для NES всегда нужно помнить, что объем оперативной памяти у нее очень ограничен - всего 2048 байт. Более того, не все из них доступны для программ на языке C.  
  
512 байт оперативной памяти используются процессором особым образом. Это результат конструкции процессора и не может быть изменено. Первые 256 байт отводятся под нулевую страницу - специальное место в оперативной памяти, причем около 48 из них используются библиотеками. Следующие 256 байт отводятся под стек процессора. К счастью, код, генерируемый компилятором C, почти не использует стек процессора - максимум 32 байта даже в больших и сложных программах. Это позволяет выделить несколько внутренних буферов в оставшемся пространстве стека. В моей библиотеке он используется для переменных звукового и музыкального плеера и внутреннего буфера палитры.  
  
Кроме этого, еще 256 байт используются для OAM-буфера, который отправляется через DMA в PPU каждый кадр. Это предусмотрено конструкцией PPU и не может быть изменено.  
  
В итоге для хранения переменных, массивов, буферов и так далее вам отводится всего 1280 байт оперативной памяти. Для сравнения, одна таблица имен занимает 1024 байта.  
  
Чтобы локальные переменные работали быстрее, нужно сделать их статическими, но это также заставляет их постоянно занимать место в оперативной памяти. Поэтому рекомендуется сделать набор глобальных переменных общего назначения, которые будут использоваться повсеместно. Глобальные переменные также немного быстрее, чем локальные статические.  
  
Вы можете получить немного дополнительной оперативной памяти, поместив некоторые переменные в нулевую страницу, где свободно около 200 байт. Это также ускорит их работу и сделает скомпилированный код немного меньше. Разместить там общий набор глобальных переменных - хорошая идея. Это можно сделать, используя эти прагмы перед переменными, которые должны попасть на нулевую страницу: #pragma bssseg (push, "ZEROPAGE")  
#pragma dataseg(push, "ZEROPAGE")  
Если вы хотите вернуть некоторые последующие переменные на обычное место, вы можете использовать эти прагмы:


> #pragma bssseg(push, "BSS")  
> #pragma dataseg(push, "BSS")  


Обратите внимание, что для следующего выпуска CC65, который в настоящее время доступен только в виде снапшота разработки, это должно быть изменено на следующее:


> #pragma bss-name(push, "ZEROPAGE")  
> #pragma data-name(push, "ZEROPAGE")  


Если вашему проекту действительно требуется больше ~1500 байт оперативной памяти, есть возможность использовать дополнительные 8K RAM. Это непростое решение, если вы собираетесь выпускать физический релиз, потому что для этого придется вставлять дополнительный чип RAM в каждый картридж. Чтобы сделать эту память пригодной для использования в CC65, нужно отредактировать nes.cfg, проверьте комментарии там.  
  
  
  
**Размер ПЗУ**  
  
Так как пример игры очень маленький, он скомпилирован как NROM128 - один 16K банк PRG ROM и один 8K банк CHR ROM. Число 128 - это размер PRG ROM в килобитах (16\*8). Для больших, но все еще безмапперных проектов следует использовать NROM256, который встречается чаще. Он имеет два банка PRG ROM по 16K, так что в общей сложности 32K для кода и данных. Чтобы перевести проект на такую конфигурацию, нужно изменить дефиницию в crt0.s и отредактировать nes.cfg - проверьте наличие комментариев, помеченных как NROM256.  
  
С помощью мапперов можно создавать и более крупные проекты. Однако я не могу рассказать об этом подробно, потому что у меня нет такого опыта. Вы можете легко управлять банками CHR через пользовательскую функцию. Однако я не думаю, что компилятор способен размещать код между банками PRG и автоматически выполнять переключение между банками, так что либо ваш код должен полностью помещаться в фиксированный банк и использовать банки для доступа к данным, либо вы должны как-то обрабатывать переключение между банками. Вы также можете поместить код и данные музыкального и звукового проигрывателя в отдельный банк, это потребует небольших изменений в коде библиотеки.  
  
Поскольку компилятор CC65 не сообщает, сколько места в ПЗУ используется в легко читаемой форме, я сделал небольшую утилиту [NES Space Checker](http://shiru.untergrund.net/files/nessp.zip), которая отображает это в виде простого графика. Возможно, он пригодится и вам. Попробуйте использовать ее на примере игры, и вы увидите, что менее четверти 16K PRG пустует.  
  
  
  
**Написание функций в ассемблерном коде**.  
  
Если вы попали в ситуацию, когда оптимизация кода на C не дает нужной скорости или размера, у вас есть выход - вручную переписать кусок кода на ассемблер. Для этого вам нужно знать ассемблер 6502 и разобраться с расположением оперативной памяти, чтобы получить место для ваших переменных. Здесь возникает вопрос, как создать интерфейс C к ассемблерной программе. Конечно, ответ на него зарыт где-то в документации и исходном коде, но чтобы сэкономить ваше время, я привожу объяснение здесь.  
  
Для начала вам нужно место, где вы будете размещать свой код. Вы можете поместить их в отдельный файл, скажем, myfuncs.s. Для этого вам нужно изменить скрипт сборки (проверить вызовы ca65 и добавить один для нового файла), затем добавить myfuncs.o в параметры ld65 перед game.o. Обычно предполагается, что один файл содержит только одну функцию, но вы можете поместить их все и в один файл. Вы можете даже не создавать никаких новых файлов и просто поместить свои функции в neslib.s, если хотите, только помните, что таким образом весь код в файле будет включен в проект, даже если он никогда не будет вызван.  
  
Вам также необходимо создать прототип функции. Поместите его в исходный код или в заголовок.  
  
Самая простая функция - это та, которая не принимает никаких параметров и ничего не возвращает:


> void \_\_fastcall\_\_ func(void);  


Аналог для сборки будет выглядеть следующим образом:


> .export \_func ;делает функцию доступной за пределами файла  
>   
> \_func:  
> ... ;ваш код  
> rts  


Теперь функция, которая принимает параметр и возвращает его:


> unsigned char \_\_fastcall\_\_ func(unsigned char n);  
>   
> .export \_func  
>   
> \_func:  
> ;n уже находится в регистре A  
> ...  
> ;поместите возвращаемое значение в регистр A  
> rts  


Для 16-битных переменных следует использовать пару X:A, с LSB в A и MSB в X.  
  
В случае более чем одного входного параметра все сложнее. Соглашение о вызове \_\_fastcall\_\_ помещает последний параметр в A или X:A, но все предыдущие параметры помещаются в программный стек, что замедляет работу. Поэтому, по возможности, следует избегать использования большого количества параметров.

> unsigned int \_\_fastcall\_\_ func(unsigned int x,unsigned int y,unsigned char n,const unsigned char \*ptr);  
>   
> .export \_func  
>   
> \_func:  
> ;ptr находится в X:A  
> jsr popa  
> ;n находится в A  
> jsr popax  
> ;y находится в X:A  
> jsr popax  
> ;x находится в X:A  
> ...  
> ;поместите возвращаемое значение в X:A  
> rts  

  
  
**Отладка**  
  
Моя низкоуровневая часть протестирована в нескольких реальных проектах и подтвердила, что она работает на реальном оборудовании. Используя ее, вы можете уменьшить шансы сделать программу, которая будет работать только в эмуляторах, но не на реальной консоли. Однако вы все равно можете написать что-то, что не будет работать на аппаратном обеспечении. Так что нелишним будет протестировать вашу программу на консоли с помощью PowerPak или каким-либо другим способом. Конечно, тестирование в эмуляторах в процессе разработки гораздо убедительнее. Используйте несколько эмуляторов для тестирования, хороший набор - Nestopia, Nintendulator, FCEUX и Mednafen - это может выявить некоторые проблемы, которые не видны в эмуляторе, который вы используете чаще всего. Тестирование в NTSC и PAL - тоже хорошая идея, например, в FCEUX есть вещи, которые видны в PAL и скрыты в NTSC.  
  
Иногда проблемы возникают на короткое время или требуют выполнения очень своевременных действий. Например, для одного кадра установлена неправильная палитра, или проверка столкновений не работает должным образом при определенных координатах. Во многих эмуляторах есть функции, которые могут сильно помочь вам разобраться с этими вещами - замедление, покадровый шаг и запись ввода.  
  
Когда вы пишете что-то, что вроде бы должно работать правильно, но не работает, начинается настоящее веселье. Проблема в том, что удобных отладчиков для Си-кода, скомпилированного в ассемблер 6502, пока не так много - таких, чтобы можно было ставить точки останова на случайных строках Си и смотреть, что в данный момент содержат переменные. Единственный отладчик уровня Си на данный момент доступен в NESICIDE. Обычно отладчик на уровне ассемблера есть только в некоторых эмуляторах, и он не очень полезен при работе с компилированным кодом.  
  
Одна из вещей, которая может немного помочь разобраться, в чем дело, - это вывод фрагментов исходного кода на Си в качестве комментариев к сгенерированному ассемблерному коду. Это уже включено в сценарии сборки примера игры. Компилятор помещает код, сгенерированный из game.c, в game.s. Вы можете увидеть этот файл после запуска compile.bat и до нажатия любой клавиши. Это также удобно, когда вы хотите проверить, насколько эффективно был скомпилирован ваш код на C, и хотите попробовать некоторые идеи, чтобы сделать его компиляцию лучше.  
  
Вы можете использовать такие вещи, как while(1); в качестве грубой точки останова, или использовать звуковые эффекты в качестве подтверждения того, что определенная часть кода достигнута, и т. д.  
  
Если вам нужно вывести отладочное значение, вы можете поместить его в неиспользуемое место оперативной памяти, обычно это конец нулевой страницы, и проверить его с помощью встроенного просмотрщика памяти в эмуляторе. Некоторые эмуляторы также позволяют следить за адресом более удобным способом. В языке C можно использовать указатели, чтобы записать что-то в адрес:

> \*(unsigned char\*)0x00ff=1; //записываем 1 в $00ff, это последний байт нулевой страницы  

  
  
**Альтернативы**  
  
В этой статье я рассказал только о своем собственном подходе к этому вопросу. Для некоторых инструментов, кода и методов, упомянутых в статье, существуют альтернативы, так что у вас есть выбор. Я рекомендую вам посмотреть [Kalle's Kanister web site](http://kkfos.aspekt.fi/), в частности проекты KNES, Pornotracker и MUSE. Другой очень перспективной альтернативой, которая будет намного проще, чем подход, описанный в этой статье, является [NESICIDE](http://www.nesicide.com/), ознакомьтесь с ней тоже.